/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
import React from 'react';
import { View, } from 'react-native';
import { CalendarHeader, } from './components/calendarHeader.component';
import { CalendarMonthHeader } from './components/calendarMonthHeader.component';
import { CalendarPicker, } from './components/picker/calendarPicker.component';
import { CalendarDateContent, } from './components/calendarDateContent.component';
import { CalendarViewModes, } from './type';
import { NativeDateService } from './service/nativeDate.service';
import { CalendarDataService, } from './service/calendarData.service';
import { Divider } from '../divider/divider.component';
const PICKER_ROWS = 4;
const PICKER_COLUMNS = 3;
const VIEWS_IN_PICKER = PICKER_ROWS * PICKER_COLUMNS;
const FORMAT_DAY = 'D';
const FORMAT_MONTH = 'MMM';
const FORMAT_YEAR = 'YYYY';
const FORMAT_HEADER_DATE = 'MMMM YYYY';
const FORMAT_HEADER_MONTH = 'YYYY';
const FORMAT_HEADER_YEAR = 'YYYY';
export class BaseCalendarComponent extends React.Component {
    constructor() {
        super(...arguments);
        this.state = {
            viewMode: this.props.startView,
            visibleDate: this.dateService.getMonthStart(this.selectedDate()),
        };
        this.dataService = new CalendarDataService(this.dateService);
        this.scrollToToday = () => {
            this.setState({
                viewMode: CalendarViewModes.DATE,
                visibleDate: this.dateService.today(),
            });
        };
        this.onDaySelect = ({ date }) => {
            this.onDateSelect(date);
        };
        this.onMonthSelect = ({ date }) => {
            const nextVisibleDate = this.dateService.createDate(this.dateService.getYear(this.state.visibleDate), this.dateService.getMonth(date), this.dateService.getDate(this.state.visibleDate));
            this.setState({
                viewMode: this.state.viewMode.pickNext(),
                visibleDate: nextVisibleDate,
            });
        };
        this.onYearSelect = ({ date }) => {
            const nextVisibleDate = this.dateService.createDate(this.dateService.getYear(date), this.dateService.getMonth(this.state.visibleDate), this.dateService.getDate(this.state.visibleDate));
            this.setState({
                viewMode: this.state.viewMode.pickNext(),
                visibleDate: nextVisibleDate,
            });
        };
        this.onPickerNavigationPress = () => {
            this.setState({
                viewMode: this.state.viewMode.navigationNext(),
            });
        };
        this.onHeaderNavigationLeftPress = () => {
            this.setState({
                visibleDate: this.createViewModeVisibleDate(-1),
            });
        };
        this.onHeaderNavigationRightPress = () => {
            this.setState({
                visibleDate: this.createViewModeVisibleDate(1),
            });
        };
        this.getCalendarStyle = (source) => {
            return {
                container: {
                    width: source.width,
                    paddingVertical: source.paddingVertical,
                    borderColor: source.borderColor,
                    borderWidth: source.borderWidth,
                    borderRadius: source.borderRadius,
                },
                headerContainer: {
                    paddingHorizontal: source.headerPaddingHorizontal,
                    paddingVertical: source.headerPaddingVertical,
                },
                title: {
                    fontSize: source.titleFontSize,
                    fontWeight: source.titleFontWeight,
                    lineHeight: source.titleLineHeight,
                    color: source.titleColor,
                    fontFamily: source.titleFontFamily,
                },
                icon: {
                    width: source.iconWidth,
                    height: source.iconHeight,
                    tintColor: source.iconTintColor,
                },
                divider: {
                    marginVertical: source.dividerMarginVertical,
                },
                daysHeaderContainer: {
                    marginHorizontal: source.rowMarginHorizontal,
                },
                row: {
                    minHeight: source.rowMinHeight,
                    marginHorizontal: source.rowMarginHorizontal,
                },
            };
        };
        this.getWeekdayStyle = (source) => {
            return {
                fontSize: source.weekdayTextFontSize,
                fontWeight: source.weekdayTextFontWeight,
                lineHeight: source.weekdayTextLineHeight,
                color: source.weekdayTextColor,
                fontFamily: source.weekdayTextFontFamily,
            };
        };
        this.isDaySelected = ({ date }) => {
            return this.isDateSelected(date);
        };
        this.isMonthSelected = ({ date }) => {
            return this.dateService.isSameMonthSafe(date, this.selectedDate());
        };
        this.isYearSelected = ({ date }) => {
            return this.dateService.isSameYearSafe(date, this.selectedDate());
        };
        this.isDayDisabled = ({ date }) => {
            const minDayStart = this.dateService.createDate(this.dateService.getYear(this.min), this.dateService.getMonth(this.min), this.dateService.getDate(this.min));
            const maxDayStart = this.dateService.createDate(this.dateService.getYear(this.max), this.dateService.getMonth(this.max), this.dateService.getDate(this.max));
            const fitsFilter = this.props.filter && !this.props.filter(date) || false;
            return !this.dateService.isBetweenIncludingSafe(date, minDayStart, maxDayStart) || fitsFilter;
        };
        this.isMonthDisabled = ({ date }) => {
            const minMonthStart = this.dateService.getMonthStart(this.min);
            const maxMonthStart = this.dateService.getMonthStart(this.max);
            return !this.dateService.isBetweenIncludingSafe(date, minMonthStart, maxMonthStart);
        };
        this.isYearDisabled = ({ date }) => {
            const minYearStart = this.dateService.getYearStart(this.min);
            const maxYearStart = this.dateService.getYearEnd(this.max);
            return !this.dateService.isBetweenIncludingSafe(date, minYearStart, maxYearStart);
        };
        this.isDayToday = ({ date }) => {
            return this.dateService.isSameDaySafe(date, this.dateService.today());
        };
        this.isMonthToday = (date) => {
            return this.dateService.isSameMonthSafe(date.date, this.dateService.today());
        };
        this.isYearToday = ({ date }) => {
            return this.dateService.isSameYearSafe(date, this.dateService.today());
        };
        this.isHeaderNavigationAllowed = () => {
            return this.state.viewMode.id !== CalendarViewModes.MONTH.id;
        };
        this.createViewModeVisibleDate = (page) => {
            switch (this.state.viewMode.id) {
                case CalendarViewModes.DATE.id: {
                    return this.dateService.addMonth(this.state.visibleDate, page);
                }
                case CalendarViewModes.MONTH.id: {
                    return this.dateService.addYear(this.state.visibleDate, page);
                }
                case CalendarViewModes.YEAR.id: {
                    return this.dateService.addYear(this.state.visibleDate, VIEWS_IN_PICKER * page);
                }
            }
        };
        this.createViewModeHeaderTitle = (date, viewMode) => {
            switch (viewMode.id) {
                case CalendarViewModes.DATE.id: {
                    return this.dateService.format(date, FORMAT_HEADER_DATE);
                }
                case CalendarViewModes.MONTH.id: {
                    return this.dateService.format(date, FORMAT_HEADER_MONTH);
                }
                case CalendarViewModes.YEAR.id: {
                    const minDateFormat = this.dateService.format(this.min, FORMAT_HEADER_YEAR);
                    const maxDateFormat = this.dateService.format(this.max, FORMAT_HEADER_YEAR);
                    return `${minDateFormat} - ${maxDateFormat}`;
                }
            }
        };
        this.renderDayIfNeeded = (item, style) => {
            const shouldRender = !item.bounding || this.props.boundingMonth;
            if (shouldRender) {
                const renderSelector = this.props.renderDay || this.renderDayElement;
                return renderSelector(item, style);
            }
            return null;
        };
        this.renderWeekdayElement = (weekday, index) => {
            return (React.createElement(CalendarDateContent, { key: index, textStyle: this.getWeekdayStyle(this.props.themedStyle) }, weekday));
        };
        this.renderDayElement = ({ date }, style) => {
            return (React.createElement(CalendarDateContent, { style: style.container, textStyle: style.text }, this.dateService.format(date, FORMAT_DAY)));
        };
        this.renderMonthElement = ({ date }, style) => {
            return (React.createElement(CalendarDateContent, { style: style.container, textStyle: style.text }, this.dateService.format(date, FORMAT_MONTH)));
        };
        this.renderYearElement = ({ date }, style) => {
            return (React.createElement(CalendarDateContent, { style: style.container, textStyle: style.text }, this.dateService.format(date, FORMAT_YEAR)));
        };
        this.renderDayPickerElement = (date, style) => {
            return (React.createElement(React.Fragment, null,
                React.createElement(CalendarMonthHeader, { style: style.daysHeaderContainer, data: this.dateService.getDayOfWeekNames() }, this.renderWeekdayElement),
                React.createElement(Divider, { style: style.divider }),
                React.createElement(CalendarPicker, { rowStyle: style.row, data: this.createDates(date), onSelect: this.onDaySelect, isItemSelected: this.isDaySelected, isItemDisabled: this.isDayDisabled, isItemToday: this.isDayToday, shouldItemUpdate: this.shouldUpdateDate }, this.renderDayIfNeeded)));
        };
        this.renderMonthPickerElement = (date, style) => {
            return (React.createElement(CalendarPicker, { rowStyle: style.row, data: this.dataService.createMonthPickerData(date, PICKER_ROWS, PICKER_COLUMNS), onSelect: this.onMonthSelect, isItemSelected: this.isMonthSelected, isItemDisabled: this.isMonthDisabled, isItemToday: this.isMonthToday }, this.props.renderMonth || this.renderMonthElement));
        };
        this.renderYearPickerElement = (date, style) => {
            return (React.createElement(CalendarPicker, { rowStyle: style.row, data: this.dataService.createYearPickerData(date, PICKER_ROWS, PICKER_COLUMNS), onSelect: this.onYearSelect, isItemSelected: this.isYearSelected, isItemDisabled: this.isYearDisabled, isItemToday: this.isYearToday }, this.props.renderYear || this.renderYearElement));
        };
        this.renderPickerElement = (date, style) => {
            switch (this.state.viewMode.id) {
                case CalendarViewModes.DATE.id:
                    return this.renderDayPickerElement(date, style);
                case CalendarViewModes.MONTH.id:
                    return this.renderMonthPickerElement(date, style);
                case CalendarViewModes.YEAR.id:
                    return this.renderYearPickerElement(date, style);
            }
        };
        this.renderFooterElement = (style) => {
            if (this.props.renderFooter) {
                return this.props.renderFooter();
            }
            return null;
        };
        this.renderHeaderElement = (style) => {
            const titleSelector = this.props.title || this.createViewModeHeaderTitle;
            return (React.createElement(CalendarHeader, { style: style.headerContainer, title: titleSelector(this.state.visibleDate, this.state.viewMode), titleStyle: style.title, iconStyle: style.icon, lateralNavigationAllowed: this.isHeaderNavigationAllowed(), onTitlePress: this.onPickerNavigationPress, onNavigationLeftPress: this.onHeaderNavigationLeftPress, onNavigationRightPress: this.onHeaderNavigationRightPress }));
        };
    }
    get dateService() {
        return this.props.dateService;
    }
    get min() {
        return this.props.min || this.dateService.getYearStart(this.dateService.today());
    }
    get max() {
        return this.props.max || this.dateService.getYearEnd(this.dateService.today());
    }
    render() {
        const { style, themedStyle, ...restProps } = this.props;
        const { container, ...componentStyle } = this.getCalendarStyle(themedStyle);
        return (React.createElement(View, Object.assign({}, restProps, { style: [container, style] }),
            this.renderHeaderElement(componentStyle),
            this.renderPickerElement(this.state.visibleDate, componentStyle),
            this.renderFooterElement(componentStyle)));
    }
}
BaseCalendarComponent.defaultProps = {
    dateService: new NativeDateService(),
    boundingMonth: true,
    startView: CalendarViewModes.DATE,
};
//# sourceMappingURL=baseCalendar.component.js.map