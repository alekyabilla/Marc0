/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
import React from 'react';
import { StyleSheet, } from 'react-native';
import { ModalService } from '../../theme';
import { PopoverView, } from './popoverView.component';
import { PopoverPlacementService } from './placement.service';
import { Offsets, PlacementOptions, PopoverPlacements, } from './type';
import { MeasureElement, } from '../measure/measure.component';
import { Frame, Point, } from '../measure/type';
const POINT_OUTSCREEN = new Point(-999, -999);
/**
 * Displays content in a Modal positioned relative to child component.
 * Supports automatic positioning.
 *
 * @extends React.Component
 *
 * @property {boolean} visible - Determines whether popover is visible or not.
 *
 * @property {ReactElement} content - Determines the content of the popover.
 *
 * @property {ReactElement} children - Determines the element "above" which popover will be shown.
 *
 * @property {string | PopoverPlacement} placement - Determines the actualPlacement of the popover.
 * Can be `left`, `top`, `right`, `bottom`, `left start`, `left end`, `top start`, `top end`, `right start`,
 * `right end`, `bottom start` or `bottom end`.
 * Default is `bottom`.
 * Tip: use one of predefined placements instead of strings, e.g `PopoverPlacements.TOP`
 *
 * @property {boolean} fullWidth - Determines whether content element should have same width as child element.
 *
 * @property {boolean} allowBackdrop - Determines whether user can tap on back-drop.
 * Default is `false`.
 *
 * @property {StyleProp<ViewStyle>} backdropStyle - Determines the style of backdrop.
 *
 * @property {() => void} onBackdropPress - Determines component's behavior when the user is
 * tapping on back-drop.
 *
 * @property {ViewProps} ...ViewProps - Any props applied to View component.
 *
 * @overview-example PopoverSimpleUsage
 *
 * @overview-example PopoverPlacement
 *
 * @overview-example PopoverStyledBackdrop
 */
export class Popover extends React.Component {
    constructor() {
        super(...arguments);
        this.state = {
            childFrame: Frame.zero(),
            contentFrame: Frame.zero(),
        };
        this.contentPosition = POINT_OUTSCREEN;
        this.placementService = new PopoverPlacementService();
        this.actualPlacement = this.preferredPlacement;
        this.onChildMeasure = (childFrame) => {
            this.state.childFrame = childFrame;
            if (this.props.visible && !this.state.contentFrame) {
                this.modalId = ModalService.show(this.renderMeasuringPopoverElement(), this.backdropConfig);
            }
        };
        this.onContentMeasure = (contentFrame) => {
            this.state.contentFrame = contentFrame;
            const placementOptions = this.findPlacementOptions(contentFrame, this.state.childFrame);
            this.actualPlacement = this.placementService.find(this.preferredPlacement, placementOptions);
            const displayFrame = this.actualPlacement.frame(placementOptions);
            this.contentPosition = displayFrame.origin;
            ModalService.update(this.modalId, this.renderPopoverElement());
        };
        this.findPlacementOptions = (contentFrame, childFrame) => {
            const width = this.props.fullWidth ? childFrame.size.width : contentFrame.size.width;
            const frame = new Frame(contentFrame.origin.x, contentFrame.origin.y, width, contentFrame.size.height);
            return new PlacementOptions(frame, childFrame, Frame.window(), this.contentOffsets);
        };
        this.renderContentElement = () => {
            const contentElement = this.props.content;
            const fullWidthStyle = { width: this.state.childFrame.size.width };
            return React.cloneElement(contentElement, {
                style: [this.props.fullWidth && fullWidthStyle, contentElement.props.style],
            });
        };
        this.renderPopoverElement = () => {
            return (React.createElement(PopoverView, Object.assign({}, this.props, { contentContainerStyle: [styles.popoverView, this.contentFlexPosition], placement: this.actualPlacement.reverse() }), this.renderContentElement()));
        };
        this.renderMeasuringPopoverElement = () => {
            return (React.createElement(MeasureElement, { onMeasure: this.onContentMeasure }, this.renderPopoverElement()));
        };
        this.renderMeasuringChildElement = () => {
            return (React.createElement(MeasureElement, { onMeasure: this.onChildMeasure }, this.props.children));
        };
    }
    get preferredPlacement() {
        return PopoverPlacements.parse(this.props.placement);
    }
    get contentFlexPosition() {
        const { x: left, y: top } = this.contentPosition;
        return { left, top };
    }
    get contentOffsets() {
        const { children: childElement } = this.props;
        return Offsets.find(childElement.props.style);
    }
    get backdropConfig() {
        const { allowBackdrop, onBackdropPress, backdropStyle } = this.props;
        return { allowBackdrop, onBackdropPress, backdropStyle };
    }
    componentDidUpdate(prevProps) {
        const visibilityChanged = prevProps.visible !== this.props.visible;
        if (visibilityChanged && !this.props.visible) {
            // this.contentPosition.setValue(POINT_OUTSCREEN);
            this.contentPosition = POINT_OUTSCREEN;
            this.modalId = ModalService.hide(this.modalId);
            return;
        }
        if (visibilityChanged && this.props.visible) {
            // Needed when `children` element is rendered within dynamic containers e.g ScrollView.
            // Will re-measure `children` element to get its actual screen position.
            this.setState({ childFrame: null, contentFrame: null });
            return;
        }
        if (this.modalId && prevProps.visible && this.props.visible) {
            ModalService.update(this.modalId, this.renderPopoverElement());
        }
    }
    render() {
        if (this.props.visible) {
            return this.renderMeasuringChildElement();
        }
        return this.props.children;
    }
}
Popover.defaultProps = {
    allowBackdrop: true,
    placement: PopoverPlacements.BOTTOM,
};
const styles = StyleSheet.create({
    popoverView: {
        position: 'absolute',
    },
});
//# sourceMappingURL=popover.component.js.map